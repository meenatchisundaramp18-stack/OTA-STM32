#!/usr/bin/env python3
import argparse
import os
import sys
import time
import struct
import serial

HEADER = b"\xAA\x55"
END_MARKER = b"\x5A"
CHUNK_SIZE = 512

def open_serial_no_reset(port: str, baud: int, timeout: float) -> serial.Serial:
    ser = serial.serial_for_url(port, do_not_open=True)
    ser.baudrate = baud
    ser.timeout = timeout
    ser.write_timeout = 2.0
    ser.dtr = 0
    ser.rts = 0
    ser.open()
    return ser

def read_some(ser: serial.Serial, seconds: float) -> bytes:
    end = time.time() + seconds
    buf = bytearray()
    while time.time() < end:
        n = ser.in_waiting
        if n:
            buf += ser.read(n)
        else:
            time.sleep(0.01)
    return bytes(buf)

def read_until_any(ser: serial.Serial, patterns, overall_timeout=5.0) -> bytes:
    start = time.time()
    buf = bytearray()
    while (time.time() - start) < overall_timeout:
        b = ser.read(1)  # b'' on timeout [web:58]
        if b:
            buf += b
            for p in patterns:
                if p in buf:
                    return bytes(buf)
    raise TimeoutError(f"Timeout waiting for {patterns}. Got={bytes(buf)!r}")

def main():
    ap = argparse.ArgumentParser(description="STM32 UART uploader (PB0+RESET upload mode)")
    ap.add_argument("-p", "--port", required=True)
    ap.add_argument("-b", "--baud", type=int, default=9600)
    ap.add_argument("-f", "--file", required=True)
    ap.add_argument("--timeout", type=float, default=0.2)
    args = ap.parse_args()

    if not os.path.isfile(args.file):
        print(f"ERR: file not found: {args.file}", file=sys.stderr)
        sys.exit(2)

    fw = open(args.file, "rb").read()
    fw_size = len(fw)

    print(f"Firmware: {args.file}")
    print(f"Size: {fw_size} bytes")
    print("Action: Hold PB0, press RESET, keep holding PB0 for 1â€“2 seconds, then run this script.")

    ser = open_serial_no_reset(args.port, args.baud, args.timeout)
    try:
        time.sleep(0.8)

        startup = read_some(ser, 1.0)
        if startup:
            print("RX (startup):")
            print(startup.decode(errors="ignore"))

        if b"RDY_HDR" not in startup:
            print("Waiting for RDY_HDR...")
            read_until_any(ser, [b"RDY_HDR"], overall_timeout=10.0)

        print("Sending header AA55...")
        ser.write(HEADER)
        ser.flush()

        print("Waiting for RDY_SIZE...")
        read_until_any(ser, [b"RDY_SIZE"], overall_timeout=5.0)

        print("Sending size (uint32 little-endian)...")
        ser.write(struct.pack("<I", fw_size))
        ser.flush()

        print("Waiting for RDY_DATA...")
        read_until_any(ser, [b"RDY_DATA"], overall_timeout=25.0)

        sent = 0
        total_chunks = (fw_size + CHUNK_SIZE - 1) // CHUNK_SIZE
        for idx in range(total_chunks):
            chunk = fw[sent:sent + CHUNK_SIZE]
            ser.write(chunk)
            ser.flush()
            sent += len(chunk)

            read_until_any(ser, [b"ACK\r\n", b"ACK\n", b"ACK"], overall_timeout=8.0)
            print(f"Sent {sent}/{fw_size} ({idx+1}/{total_chunks})")

        print("Waiting for RDY_END...")
        read_until_any(ser, [b"RDY_END"], overall_timeout=5.0)

        print("Sending END marker 0x5A...")
        ser.write(END_MARKER)
        ser.flush()

        out = read_until_any(ser, [b"UPLOAD COMPLETE"], overall_timeout=6.0)
        print("RX:", out.decode(errors="ignore").strip())
        print("Done. Press RESET (without PB0) to run application.")

    finally:
        ser.close()

if __name__ == "__main__":
    main()
